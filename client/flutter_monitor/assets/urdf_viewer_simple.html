<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Robot Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; }
        #container { width: 100vw; height: 100vh; touch-action: none; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Three.js global (classic script – maximum browser compatibility) -->
    <script src="./libs/three.min.js"></script>

    <!-- Catch any error early and forward to Flutter -->
    <script>
        window.onerror = function(msg, src, line, col, err) {
            sendToFlutter({ type: 'error', message: msg + ' (' + src + ':' + line + ')' });
        };
        function sendToFlutter(msg) {
            if (window.FlutterChannel)
                window.FlutterChannel.postMessage(JSON.stringify(msg));
            else if (window.chrome && window.chrome.webview)
                window.chrome.webview.postMessage(msg);
        }
    </script>

    <script>
        /* ==============================================================
         *  Configuration
         * ============================================================== */
        const URDF_URL  = './urdf/' + encodeURIComponent('轮足狗机器人v3.urdf');

        // Maps Flutter 16-element joint array index → URDF joint name.
        // FR(hip,thigh,calf,foot) FL(…) RR(…) RL(…)
        const JOINT_ORDER = [
            'fr_hip_joint',   'fr_thigh_joint',  'fr_calf_joint',  'fr_foot_joint',
            'fl_hip_joint',   'fl_thigh_joint',  'fl_calf_joint',  'fl_foot_joint',
            'rr_hip_Link',    'rr_thigh_joint',  'rr_calf_joint',  'rr_foot_joint',
            'rl_hip_joint',   'rl_thigh_joint',  'rl_calf_joint',  'rl_foot_joint',
        ];

        /* ==============================================================
         *  State
         * ============================================================== */
        let scene, camera, renderer;
        let robotGroup;            // world-pose container
        let robot      = null;     // URDFRobot-like object with joints
        let jointMap   = {};       // name → { group, axis, type }
        let needsRender   = true;
        let isDark        = true;

        // Camera orbit (manual – no OrbitControls module needed)
        let camDist = 1.8, camPhi = Math.PI / 5, camTheta = Math.PI / 4;
        let camTarget = new THREE.Vector3(0, 0, 0.15);
        let dragging = false, lastX = 0, lastY = 0, lastPinch = 0;

        // Idle animation
        let idleEnabled = true, idleTime = 0, lastFrame = 0;

        /* ==============================================================
         *  Init
         * ============================================================== */
        function init() {
            const container = document.getElementById('container');

            // ── Scene ──────────────────────────────────────────────
            scene = new THREE.Scene();
            applyThemeColors();

            // ── Camera  (Z-up, matching URDF / ROS) ────────────────
            camera = new THREE.PerspectiveCamera(
                50, innerWidth / innerHeight, 0.01, 1000);
            camera.up.set(0, 0, 1);
            updateCamera();

            // ── Renderer (URDF-Studio quality) ─────────────────────
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
            renderer.toneMapping       = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace  = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            // ── Lighting (5-point, URDF-Studio inspired) ───────────
            setupLighting();

            // ── Ground ─────────────────────────────────────────────
            createGround();

            // ── Robot container ────────────────────────────────────
            robotGroup = new THREE.Group();
            scene.add(robotGroup);

            // ── Camera controls (inline – no module deps) ──────────
            setupControls();

            // ── Load URDF ──────────────────────────────────────────
            loadURDF();

            // ── Render loop ────────────────────────────────────────
            lastFrame = performance.now();
            animate();

            sendToFlutter({ type: 'ready', message: 'URDF viewer initialized' });
        }

        /* ==============================================================
         *  Lighting
         * ============================================================== */
        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            const hemi = new THREE.HemisphereLight(0xddeeff, 0x444444, 0.5);
            hemi.position.set(0, 0, 10);
            scene.add(hemi);

            const key = new THREE.DirectionalLight(0xffffff, 1.2);
            key.position.set(5, 7, 12);
            key.castShadow = true;
            key.shadow.camera.near   = 0.1;
            key.shadow.camera.far    = 40;
            key.shadow.camera.left   = key.shadow.camera.bottom = -4;
            key.shadow.camera.right  = key.shadow.camera.top    =  4;
            key.shadow.mapSize.set(2048, 2048);
            key.shadow.bias = -0.0002;
            scene.add(key);

            scene.add(new THREE.DirectionalLight(0x4488ff, 0.25)
                .translateX(-4).translateY(-4).translateZ(4));
            scene.add(new THREE.DirectionalLight(0xff8844, 0.15)
                .translateY(-6).translateZ(2));
        }

        /* ==============================================================
         *  Ground (Z-up)
         * ============================================================== */
        function createGround() {
            const grid = new THREE.GridHelper(20, 40, 0x444444, 0x333333);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(40, 40),
                new THREE.MeshStandardMaterial({ color: 0x1a1a2e, roughness: 1.0 })
            );
            ground.position.z    = -0.002;
            ground.receiveShadow = true;
            ground.name          = '_ground';
            scene.add(ground);

            const axes = new THREE.AxesHelper(0.3);
            axes.position.z = 0.005;
            scene.add(axes);
        }

        /* ==============================================================
         *  URDF Loading  (inline parser – no ES module dependency)
         * ============================================================== */
        function loadURDF() {
            fetch(URDF_URL)
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.text();
                })
                .then(xml => parseAndBuildURDF(xml))
                .catch(e => {
                    console.error('URDF fetch failed:', e);
                    sendToFlutter({ type: 'error', message: 'URDF load failed: ' + e.message });
                });
        }

        /**
         * Lightweight URDF parser (inspired by URDF-Studio's URDFLoader).
         * Parses <link> and <joint> elements, builds a Three.js Group
         * hierarchy, and loads STL meshes.
         */
        function parseAndBuildURDF(xmlText) {
            const parser = new DOMParser();
            const doc    = parser.parseFromString(xmlText, 'text/xml');
            const robotEl = doc.querySelector('robot');
            if (!robotEl) { sendToFlutter({ type:'error', message:'No <robot> in URDF' }); return; }

            const linkMap = {};   // name → THREE.Group
            const linkEls = robotEl.querySelectorAll(':scope > link');
            const jointEls = robotEl.querySelectorAll(':scope > joint');

            // ── 1. Create link groups ──────────────────────────────
            let meshesTotal = 0, meshesLoaded = 0;

            linkEls.forEach(linkEl => {
                const name  = linkEl.getAttribute('name');
                const group = new THREE.Group();
                group.name  = name;
                linkMap[name] = group;

                // Visual geometries
                linkEl.querySelectorAll(':scope > visual').forEach(vis => {
                    const originEl = vis.querySelector('origin');
                    const geoEl    = vis.querySelector('geometry');
                    const matEl    = vis.querySelector('material');

                    let color = new THREE.Color(0x8899aa);
                    if (matEl) {
                        const cEl = matEl.querySelector('color');
                        if (cEl) {
                            const rgba = cEl.getAttribute('rgba').trim().split(/\s+/).map(Number);
                            color.setRGB(rgba[0], rgba[1], rgba[2]);
                        }
                    }

                    const visGroup = new THREE.Group();
                    if (originEl) {
                        const xyz = tupleF(originEl.getAttribute('xyz'));
                        const rpy = tupleF(originEl.getAttribute('rpy'));
                        visGroup.position.set(xyz[0], xyz[1], xyz[2]);
                        applyRPY(visGroup, rpy);
                    }

                    if (geoEl) {
                        const child = geoEl.children[0];
                        if (!child) return;
                        const tag = child.tagName.toLowerCase();

                        if (tag === 'mesh') {
                            const fn = child.getAttribute('filename');
                            if (!fn) return;
                            // Resolve package:// paths
                            const url = fn.replace(/^package:\/\/[^/]+\//, './');
                            meshesTotal++;
                            loadSTL(url, color, mesh => {
                                if (mesh) visGroup.add(mesh);
                                meshesLoaded++;
                                if (meshesLoaded === meshesTotal) onAllMeshesLoaded();
                            });
                        } else if (tag === 'box') {
                            const s = tupleF(child.getAttribute('size'));
                            const m = makePBRMesh(new THREE.BoxGeometry(s[0], s[1], s[2]), color);
                            visGroup.add(m);
                        } else if (tag === 'cylinder') {
                            const r = parseFloat(child.getAttribute('radius') || '0');
                            const l = parseFloat(child.getAttribute('length') || '0');
                            const g = new THREE.CylinderGeometry(r, r, l, 30);
                            g.rotateX(Math.PI / 2); // URDF cylinder is Z-axis aligned
                            visGroup.add(makePBRMesh(g, color));
                        } else if (tag === 'sphere') {
                            const r = parseFloat(child.getAttribute('radius') || '0');
                            visGroup.add(makePBRMesh(new THREE.SphereGeometry(r, 30, 30), color));
                        }
                    }
                    group.add(visGroup);
                });
            });

            // ── 2. Build joint hierarchy ───────────────────────────
            // Determine root link (not a child of any joint)
            const childLinks = new Set();
            jointEls.forEach(jEl => {
                const c = jEl.querySelector('child');
                if (c) childLinks.add(c.getAttribute('link'));
            });
            let rootName = null;
            linkEls.forEach(lEl => {
                const n = lEl.getAttribute('name');
                if (!childLinks.has(n)) rootName = n;
            });

            jointEls.forEach(jEl => {
                const jName  = jEl.getAttribute('name');
                const jType  = jEl.getAttribute('type') || 'fixed';
                const parentName = jEl.querySelector('parent')?.getAttribute('link');
                const childName  = jEl.querySelector('child')?.getAttribute('link');
                if (!parentName || !childName) return;

                const originEl = jEl.querySelector('origin');
                const axisEl   = jEl.querySelector('axis');

                const jGroup = new THREE.Group();
                jGroup.name  = jName;
                if (originEl) {
                    const xyz = tupleF(originEl.getAttribute('xyz'));
                    const rpy = tupleF(originEl.getAttribute('rpy'));
                    jGroup.position.set(xyz[0], xyz[1], xyz[2]);
                    applyRPY(jGroup, rpy);
                }

                let axisVec = new THREE.Vector3(1, 0, 0);
                if (axisEl) {
                    const a = tupleF(axisEl.getAttribute('xyz'));
                    axisVec.set(a[0], a[1], a[2]).normalize();
                }

                // Store joint info for runtime angle control
                if (jType === 'revolute' || jType === 'continuous' || jType === 'prismatic') {
                    jointMap[jName] = { group: jGroup, axis: axisVec, type: jType };
                }

                // Hierarchy: parent → jGroup → child
                const parentGroup = linkMap[parentName];
                const childGroup  = linkMap[childName];
                if (parentGroup && childGroup) {
                    parentGroup.add(jGroup);
                    jGroup.add(childGroup);
                }
            });

            // ── 3. Add root to scene ───────────────────────────────
            const rootGroup = linkMap[rootName];
            if (rootGroup) {
                robotGroup.add(rootGroup);
                robot = rootGroup;
            }

            // If no meshes to load, we're done immediately
            if (meshesTotal === 0) onAllMeshesLoaded();
        }

        function onAllMeshesLoaded() {
            if (!robot) return;

            // Offset so feet touch Z = 0
            const box = new THREE.Box3().setFromObject(robot);
            robot.position.z = -box.min.z;

            needsRender = true;
            sendToFlutter({
                type: 'info',
                message: 'URDF loaded (' + Object.keys(jointMap).length + ' joints)',
            });
        }

        /* ==============================================================
         *  Helpers
         * ============================================================== */
        function tupleF(s) {
            if (!s) return [0, 0, 0];
            return s.trim().split(/\s+/).map(Number);
        }

        function applyRPY(obj, rpy) {
            if (!rpy) return;
            const q = new THREE.Quaternion();
            const e = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'ZYX');
            q.setFromEuler(e);
            q.multiply(obj.quaternion);
            obj.quaternion.copy(q);
        }

        function makePBRMesh(geometry, color) {
            const mat = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.25,
                roughness: 0.55,
            });
            const m = new THREE.Mesh(geometry, mat);
            m.castShadow = m.receiveShadow = true;
            return m;
        }

        /* ==============================================================
         *  STL Loader (inline binary parser)
         * ============================================================== */
        function loadSTL(url, color, cb) {
            fetch(encodeURI(url))
                .then(r => { if (!r.ok) throw new Error('HTTP ' + r.status); return r.arrayBuffer(); })
                .then(buf => {
                    const geom = parseSTLBinary(buf);
                    geom.computeVertexNormals();
                    cb(makePBRMesh(geom, color));
                })
                .catch(e => { console.warn('STL fail:', url, e.message); cb(null); });
        }

        function parseSTLBinary(buf) {
            const dv = new DataView(buf);
            const n  = dv.getUint32(80, true);
            const verts = new Float32Array(n * 9);
            const norms = new Float32Array(n * 9);
            let off = 84;
            for (let i = 0; i < n; i++) {
                const nx = dv.getFloat32(off, true); off += 4;
                const ny = dv.getFloat32(off, true); off += 4;
                const nz = dv.getFloat32(off, true); off += 4;
                for (let j = 0; j < 3; j++) {
                    const bi = i * 9 + j * 3;
                    verts[bi]     = dv.getFloat32(off, true); off += 4;
                    verts[bi + 1] = dv.getFloat32(off, true); off += 4;
                    verts[bi + 2] = dv.getFloat32(off, true); off += 4;
                    norms[bi] = nx; norms[bi + 1] = ny; norms[bi + 2] = nz;
                }
                off += 2;
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            g.setAttribute('normal',   new THREE.BufferAttribute(norms, 3));
            return g;
        }

        /* ==============================================================
         *  Joint Control
         * ============================================================== */
        function setJointByName(name, angle) {
            const j = jointMap[name];
            if (!j) return;
            if (j.type === 'prismatic') {
                j.group.position.copy(j.origPos || j.group.position);
                j.group.position.addScaledVector(j.axis, angle);
            } else {
                j.group.quaternion.setFromAxisAngle(j.axis, angle);
            }
        }

        /** Set all 16 joint angles at once (radians). */
        function updateJointAngles(angles) {
            if (!robot || !angles || angles.length < 16) return;
            idleEnabled = false;
            for (let i = 0; i < JOINT_ORDER.length && i < angles.length; i++) {
                setJointByName(JOINT_ORDER[i], angles[i]);
            }
            needsRender = true;
        }

        /** Set a single joint by index. */
        function setJointAngle(index, angle) {
            if (index < 0 || index >= JOINT_ORDER.length) return;
            setJointByName(JOINT_ORDER[index], angle);
            needsRender = true;
        }

        /* ==============================================================
         *  Robot Pose
         * ============================================================== */
        function updateRobotPose(x, y, z, qx, qy, qz, qw) {
            if (!robotGroup) return;
            robotGroup.position.set(x, y, z);
            robotGroup.quaternion.set(qx, qy, qz, qw);
            needsRender = true;
        }

        /* ==============================================================
         *  Idle Animation
         * ============================================================== */
        function tickIdle(dt) {
            if (!idleEnabled || !robot) return;
            idleTime += dt;
            const t = idleTime, A = 0.12, f = 0.6;
            const p1 = Math.sin(2 * Math.PI * f * t) * A;
            const p2 = Math.sin(2 * Math.PI * f * t + Math.PI) * A;
            const hp = Math.sin(Math.PI * f * t) * 0.04;

            const s = setJointByName;
            s('fr_hip_joint', hp);   s('fr_thigh_joint', p1);
            s('fr_calf_joint', -p1*1.6); s('fr_foot_joint', p1*0.4);
            s('fl_hip_joint', -hp);  s('fl_thigh_joint', p2);
            s('fl_calf_joint', -p2*1.6); s('fl_foot_joint', p2*0.4);
            s('rr_hip_Link', -hp);   s('rr_thigh_joint', p2);
            s('rr_calf_joint', -p2*1.6); s('rr_foot_joint', p2*0.4);
            s('rl_hip_joint', hp);   s('rl_thigh_joint', p1);
            s('rl_calf_joint', -p1*1.6); s('rl_foot_joint', p1*0.4);
            needsRender = true;
        }

        function enableIdleAnimation(en) {
            idleEnabled = !!en;
            if (en) idleTime = 0;
            needsRender = true;
        }

        /* ==============================================================
         *  Theme
         * ============================================================== */
        function setTheme(theme) {
            isDark = theme !== 'light';
            applyThemeColors();
            needsRender = true;
        }
        function applyThemeColors() {
            const bg = isDark ? 0x1a1a2e : 0xf0f2f6;
            if (scene) {
                scene.background = new THREE.Color(bg);
                scene.fog = new THREE.Fog(bg, 10, 50);
            }
            document.body.style.background = '#' + bg.toString(16).padStart(6, '0');
            const gnd = scene && scene.getObjectByName('_ground');
            if (gnd && gnd.material) gnd.material.color.set(bg);
        }

        /* ==============================================================
         *  Camera view presets
         * ============================================================== */
        function setViewMode(mode) {
            camTarget.set(0, 0, 0.15);
            if (mode === 'top')        { camDist=3; camPhi=0.01; camTheta=0; }
            else if (mode === 'front') { camDist=2; camPhi=Math.PI/2; camTheta=0; }
            else if (mode === 'side')  { camDist=2; camPhi=Math.PI/2; camTheta=Math.PI/2; }
            else                       { camDist=1.8; camPhi=Math.PI/5; camTheta=Math.PI/4; }
            updateCamera();
        }

        /* ==============================================================
         *  Camera Orbit Controls (inline, Z-up)
         * ============================================================== */
        function updateCamera() {
            // Spherical → Cartesian (Z-up)
            camera.position.set(
                camDist * Math.sin(camPhi) * Math.cos(camTheta) + camTarget.x,
                camDist * Math.sin(camPhi) * Math.sin(camTheta) + camTarget.y,
                camDist * Math.cos(camPhi) + camTarget.z
            );
            camera.lookAt(camTarget);
            needsRender = true;
        }

        function setupControls() {
            const el = renderer.domElement;
            const start = (x,y) => { dragging = true; lastX = x; lastY = y; };
            const move  = (x,y) => {
                if (!dragging) return;
                camTheta -= (x - lastX) * 0.008;
                camPhi    = Math.max(0.05, Math.min(Math.PI * 0.95,
                            camPhi + (y - lastY) * 0.008));
                lastX = x; lastY = y;
                updateCamera();
            };
            const end = () => dragging = false;

            el.addEventListener('mousedown', e => { e.preventDefault(); start(e.clientX, e.clientY); });
            el.addEventListener('mousemove', e => { if (dragging) { e.preventDefault(); move(e.clientX, e.clientY); } });
            el.addEventListener('mouseup', end);
            el.addEventListener('mouseleave', end);
            el.addEventListener('touchstart', e => {
                e.preventDefault();
                if (e.touches.length === 1) start(e.touches[0].clientX, e.touches[0].clientY);
                else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastPinch = Math.sqrt(dx*dx + dy*dy);
                }
            });
            el.addEventListener('touchmove', e => {
                e.preventDefault();
                if (e.touches.length === 1 && dragging) move(e.touches[0].clientX, e.touches[0].clientY);
                else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    camDist = Math.max(0.3, Math.min(8, camDist - (d - lastPinch) * 0.005));
                    lastPinch = d;
                    updateCamera();
                }
            });
            el.addEventListener('touchend', e => { e.preventDefault(); if (!e.touches.length) end(); });
            el.addEventListener('wheel', e => {
                e.preventDefault();
                camDist = Math.max(0.3, Math.min(8, camDist + e.deltaY * 0.001));
                updateCamera();
            }, { passive: false });
        }

        /* ==============================================================
         *  Render Loop
         * ============================================================== */
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt  = (now - lastFrame) / 1000;
            lastFrame = now;
            tickIdle(dt);
            if (needsRender) { renderer.render(scene, camera); needsRender = false; }
        }

        addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            needsRender = true;
        });

        /* ==============================================================
         *  Flutter ↔ JS Bridge
         * ============================================================== */
        // sendToFlutter defined above (before modules, catches errors too)

        // Expose API
        window.updateRobotPose     = updateRobotPose;
        window.updateJointAngles   = updateJointAngles;
        window.setJointAngle       = setJointAngle;
        window.enableIdleAnimation = enableIdleAnimation;
        window.setTheme            = setTheme;
        window.setViewMode         = setViewMode;

        // ── Boot ──────────────────────────────────────────────────
        if (document.readyState === 'complete') init();
        else addEventListener('load', init);
    </script>
</body>
</html>
