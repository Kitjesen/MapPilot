#ifdef WEBRTC_ENABLED

#include "remote_monitoring/webrtc_bridge.hpp"

#include <chrono>
#include <cstring>
#include <sstream>

#ifdef X264_ENABLED
extern "C" {
#include <x264.h>
}
#endif

#include <opencv2/core.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>

namespace remote_monitoring {

// ==================== WebRTCPeer Implementation ====================

WebRTCPeer::WebRTCPeer(const std::string &session_id)
    : session_id_(session_id) {
  RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"), 
              "Creating WebRTC peer for session: %s", session_id.c_str());
}

WebRTCPeer::~WebRTCPeer() {
  Close();
}

bool WebRTCPeer::Initialize(const rtc::Configuration &config) {
  std::lock_guard<std::mutex> lock(mutex_);
  
  try {
    peer_connection_ = std::make_shared<rtc::PeerConnection>(config);
    
    // 设置回调 — 注意：不在这里创建 DataChannel/Track，
    // 避免 libdatachannel 自动生成 offer 导致 SDP glare。
    // DataChannel/Track 在 SetupMedia() 中创建（收到远端 offer 之后）。
    
    peer_connection_->onLocalDescription([this](rtc::Description description) {
      // Suppress auto-offer generated by DataChannel creation before remote offer is set
      if (suppress_local_desc_.load()) {
        RCLCPP_DEBUG(rclcpp::get_logger("WebRTCPeer"),
                    "Suppressed auto-generated local description (type: %s) during DC setup",
                    description.typeString().c_str());
        return;
      }
      
      std::string sdp = std::string(description);
      std::string type = description.typeString();
      
      RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                  "Local description generated (type: %s)", type.c_str());
      
      if (on_local_description_) {
        on_local_description_(sdp, type);
      }
    });
    
    peer_connection_->onLocalCandidate([this](rtc::Candidate candidate) {
      std::string cand = std::string(candidate);
      std::string mid = candidate.mid();
      
      RCLCPP_DEBUG(rclcpp::get_logger("WebRTCPeer"),
                   "Local ICE candidate: %s", cand.c_str());
      
      if (on_local_candidate_) {
        on_local_candidate_(cand, mid);
      }
    });
    
    peer_connection_->onStateChange([this](rtc::PeerConnection::State state) {
      RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                  "Connection state changed: %d", static_cast<int>(state));
      
      connected_ = (state == rtc::PeerConnection::State::Connected);
      
      if (on_state_change_) {
        on_state_change_(state);
      }
    });
    
    peer_connection_->onGatheringStateChange([this](rtc::PeerConnection::GatheringState state) {
      RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                  "ICE gathering state changed: %d", static_cast<int>(state));
      
      if (on_gathering_state_change_) {
        on_gathering_state_change_(state);
      }
    });
    
    RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                "WebRTC peer initialized (callbacks set, awaiting offer before media setup)");
    return true;
    
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to initialize peer connection: %s", e.what());
    return false;
  }
}

void WebRTCPeer::SetupMedia() {
  std::lock_guard<std::mutex> lock(mutex_);
  
  if (!peer_connection_) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Cannot setup media: peer connection not initialized");
    return;
  }
  
  try {
    // 创建 DataChannel 用于传输 JPEG 帧 (unreliable + unordered 以降低延迟)
    // 注意：调用前须设置 suppress_local_desc_ = true 以防 auto-offer
    rtc::DataChannelInit dc_init;
    dc_init.reliability.unordered = true;          // 不保序，降低延迟
    dc_init.reliability.maxRetransmits = 0;        // 不重传，丢帧优于延迟
    
    video_data_channel_ = peer_connection_->createDataChannel("video-jpeg", dc_init);
    
    video_data_channel_->onOpen([this]() {
      data_channel_open_ = true;
      RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                  "DataChannel 'video-jpeg' opened for session: %s", session_id_.c_str());
    });
    
    video_data_channel_->onClosed([this]() {
      data_channel_open_ = false;
      RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                  "DataChannel 'video-jpeg' closed for session: %s", session_id_.c_str());
    });
    
    video_data_channel_->onError([this](std::string error) {
      RCLCPP_WARN(rclcpp::get_logger("WebRTCPeer"),
                  "DataChannel error: %s (session: %s)", error.c_str(), session_id_.c_str());
    });
    
    RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                "Media setup complete: DataChannel 'video-jpeg' created for session: %s",
                session_id_.c_str());
                
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to setup media: %s", e.what());
  }
}

void WebRTCPeer::SetRemoteDescription(const std::string &sdp, const std::string &type) {
  std::lock_guard<std::mutex> lock(mutex_);
  
  if (!peer_connection_) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Peer connection not initialized");
    return;
  }
  
  try {
    rtc::Description::Type desc_type = (type == "offer") 
        ? rtc::Description::Type::Offer 
        : rtc::Description::Type::Answer;
    
    rtc::Description description(sdp, desc_type);
    peer_connection_->setRemoteDescription(description);
    
    RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
                "Remote description set (type: %s)", type.c_str());
                
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to set remote description: %s", e.what());
  }
}

void WebRTCPeer::CreateAnswer() {
  std::lock_guard<std::mutex> lock(mutex_);
  
  if (!peer_connection_) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Peer connection not initialized");
    return;
  }
  
  try {
    peer_connection_->setLocalDescription(rtc::Description::Type::Answer);
    RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"), "Creating answer...");
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to create answer: %s", e.what());
  }
}

void WebRTCPeer::AddRemoteCandidate(const std::string &candidate, const std::string &mid) {
  std::lock_guard<std::mutex> lock(mutex_);
  
  if (!peer_connection_) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Peer connection not initialized");
    return;
  }
  
  try {
    rtc::Candidate cand(candidate, mid);
    peer_connection_->addRemoteCandidate(cand);
    
    RCLCPP_DEBUG(rclcpp::get_logger("WebRTCPeer"),
                 "Added remote ICE candidate");
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to add remote candidate: %s", e.what());
  }
}

void WebRTCPeer::SendVideoFrame(const uint8_t *data, size_t size, uint64_t /*timestamp_us*/) {
  // 优先通过 DataChannel 发送 JPEG 帧 (无需 H.264 编码)
  if (!data_channel_open_ || !connected_) {
    return;
  }
  
  try {
    if (video_data_channel_ && video_data_channel_->isOpen()) {
      auto byte_ptr = reinterpret_cast<const std::byte *>(data);
      video_data_channel_->send(byte_ptr, size);
    }
  } catch (const std::exception &e) {
    RCLCPP_ERROR(rclcpp::get_logger("WebRTCPeer"),
                 "Failed to send video frame via DataChannel: %s", e.what());
  }
}

bool WebRTCPeer::IsConnected() const {
  return connected_.load();
}

void WebRTCPeer::SetOnLocalDescription(OnLocalDescriptionCallback cb) {
  on_local_description_ = std::move(cb);
}

void WebRTCPeer::SetOnLocalCandidate(OnLocalCandidateCallback cb) {
  on_local_candidate_ = std::move(cb);
}

void WebRTCPeer::SetOnStateChange(OnStateChangeCallback cb) {
  on_state_change_ = std::move(cb);
}

void WebRTCPeer::SetOnGatheringStateChange(OnGatheringStateChangeCallback cb) {
  on_gathering_state_change_ = std::move(cb);
}

void WebRTCPeer::Close() {
  std::lock_guard<std::mutex> lock(mutex_);
  
  connected_ = false;
  data_channel_open_ = false;
  
  if (video_data_channel_) {
    video_data_channel_->close();
    video_data_channel_.reset();
  }
  
  if (video_track_) {
    video_track_.reset();
  }
  
  if (peer_connection_) {
    peer_connection_->close();
    peer_connection_.reset();
  }
  
  RCLCPP_INFO(rclcpp::get_logger("WebRTCPeer"),
              "WebRTC peer closed: %s", session_id_.c_str());
}

// ==================== WebRTCBridge Implementation ====================

WebRTCBridge::WebRTCBridge(rclcpp::Node *node)
    : node_(node) {
  RCLCPP_INFO(node_->get_logger(), "WebRTCBridge created");
}

WebRTCBridge::~WebRTCBridge() {
  UnsubscribeCameraTopic();
  DestroyEncoder();
  
  // 关闭所有 peer 连接
  std::lock_guard<std::mutex> lock(peers_mutex_);
  for (auto &[id, peer] : peers_) {
    peer->Close();
  }
  peers_.clear();
  
  RCLCPP_INFO(node_->get_logger(), "WebRTCBridge destroyed");
}

bool WebRTCBridge::Initialize() {
  if (initialized_) {
    return true;
  }
  
  // 从参数获取 STUN/TURN 服务器配置
  std::string stun_server = node_->declare_parameter<std::string>(
      "webrtc.stun_server", "stun:stun.l.google.com:19302");
  
  std::string turn_server = node_->declare_parameter<std::string>(
      "webrtc.turn_server", "");
  std::string turn_username = node_->declare_parameter<std::string>(
      "webrtc.turn_username", "");
  std::string turn_password = node_->declare_parameter<std::string>(
      "webrtc.turn_password", "");
  
  // 配置 ICE 服务器
  rtc_config_.iceServers.push_back(rtc::IceServer(stun_server));
  
  if (!turn_server.empty() && !turn_username.empty()) {
    // TURN server: hostname, service(port), username, password, relay type
    // Parse turn_server which may be "turn:host:port" or just "host:port"
    std::string turn_host = turn_server;
    std::string turn_port = "3478";
    // Strip "turn:" prefix if present
    if (turn_host.find("turn:") == 0) {
      turn_host = turn_host.substr(5);
    }
    // Extract port if present
    auto colon_pos = turn_host.rfind(':');
    if (colon_pos != std::string::npos) {
      turn_port = turn_host.substr(colon_pos + 1);
      turn_host = turn_host.substr(0, colon_pos);
    }
    rtc_config_.iceServers.push_back(
        rtc::IceServer(turn_host, turn_port, turn_username, turn_password,
                       rtc::IceServer::RelayType::TurnUdp));
  }
  
  RCLCPP_INFO(node_->get_logger(), 
              "WebRTCBridge initialized with STUN server: %s", stun_server.c_str());
  
  initialized_ = true;
  return true;
}

std::shared_ptr<WebRTCPeer> WebRTCBridge::CreatePeer(const std::string &session_id) {
  if (!initialized_) {
    RCLCPP_ERROR(node_->get_logger(), 
                 "WebRTCBridge not initialized, cannot create peer");
    return nullptr;
  }
  
  std::lock_guard<std::mutex> lock(peers_mutex_);
  
  // 检查是否已存在
  auto it = peers_.find(session_id);
  if (it != peers_.end()) {
    RCLCPP_WARN(node_->get_logger(),
                "Peer already exists for session: %s", session_id.c_str());
    return it->second;
  }
  
  // 创建新的 peer
  auto peer = std::make_shared<WebRTCPeer>(session_id);
  
  if (!peer->Initialize(rtc_config_)) {
    RCLCPP_ERROR(node_->get_logger(),
                 "Failed to initialize peer for session: %s", session_id.c_str());
    return nullptr;
  }
  
  // 设置回调以转发到 bridge 级别
  peer->SetOnLocalDescription([this, session_id](const std::string &sdp, const std::string &type) {
    if (on_local_description_) {
      on_local_description_(session_id, sdp, type);
    }
  });
  
  peer->SetOnLocalCandidate([this, session_id](const std::string &candidate, const std::string &mid) {
    if (on_local_candidate_) {
      on_local_candidate_(session_id, candidate, mid);
    }
  });
  
  peer->SetOnStateChange([this, session_id](rtc::PeerConnection::State state) {
    std::string state_str;
    switch (state) {
      case rtc::PeerConnection::State::New: state_str = "new"; break;
      case rtc::PeerConnection::State::Connecting: state_str = "connecting"; break;
      case rtc::PeerConnection::State::Connected: state_str = "connected"; break;
      case rtc::PeerConnection::State::Disconnected: state_str = "disconnected"; break;
      case rtc::PeerConnection::State::Failed: state_str = "failed"; break;
      case rtc::PeerConnection::State::Closed: state_str = "closed"; break;
      default: state_str = "unknown"; break;
    }
    
    if (on_connection_state_) {
      on_connection_state_(session_id, state_str);
    }
  });
  
  peer->SetOnGatheringStateChange([this, session_id](rtc::PeerConnection::GatheringState state) {
    if (state == rtc::PeerConnection::GatheringState::Complete) {
      if (on_ice_gathering_done_) {
        on_ice_gathering_done_(session_id);
      }
    }
  });
  
  peers_[session_id] = peer;
  
  RCLCPP_INFO(node_->get_logger(), 
              "Created WebRTC peer for session: %s (total peers: %zu)",
              session_id.c_str(), peers_.size());
  
  return peer;
}

std::shared_ptr<WebRTCPeer> WebRTCBridge::GetPeer(const std::string &session_id) {
  std::lock_guard<std::mutex> lock(peers_mutex_);
  auto it = peers_.find(session_id);
  return (it != peers_.end()) ? it->second : nullptr;
}

void WebRTCBridge::RemovePeer(const std::string &session_id) {
  std::lock_guard<std::mutex> lock(peers_mutex_);
  
  auto it = peers_.find(session_id);
  if (it != peers_.end()) {
    it->second->Close();
    peers_.erase(it);
    
    RCLCPP_INFO(node_->get_logger(),
                "Removed WebRTC peer: %s (remaining: %zu)",
                session_id.c_str(), peers_.size());
  }
}

void WebRTCBridge::HandleOffer(const std::string &session_id, const std::string &sdp) {
  auto peer = GetPeer(session_id);
  
  if (!peer) {
    peer = CreatePeer(session_id);
    if (!peer) {
      RCLCPP_ERROR(node_->get_logger(),
                   "Failed to create peer for offer: %s", session_id.c_str());
      return;
    }
  }
  
  // 正确的协商顺序（解决 DataChannel 不在 Answer SDP 中的问题）：
  //   1. 抑制自动生成的 offer（创建 DataChannel 会触发 libdatachannel 自动 offer）
  //   2. 创建 DataChannel "video-jpeg"
  //   3. 取消抑制
  //   4. 设置远端 offer → libdatachannel 自动生成包含 DataChannel 的 answer
  // 这样 DataChannel 会被包含在 Answer SDP 中，客户端才能收到 onDataChannel 回调。
  peer->suppress_local_desc_ = true;
  peer->SetupMedia();
  peer->suppress_local_desc_ = false;
  peer->SetRemoteDescription(sdp, "offer");
  // libdatachannel 会自动在 setRemoteDescription(offer) 后生成 answer，无需手动调用
}

void WebRTCBridge::HandleIceCandidate(const std::string &session_id,
                                       const std::string &candidate,
                                       const std::string &mid) {
  auto peer = GetPeer(session_id);
  
  if (!peer) {
    RCLCPP_WARN(node_->get_logger(),
                "No peer found for ICE candidate: %s", session_id.c_str());
    return;
  }
  
  peer->AddRemoteCandidate(candidate, mid);
}

void WebRTCBridge::SetOnLocalDescription(OnLocalDescriptionCallback cb) {
  on_local_description_ = std::move(cb);
}

void WebRTCBridge::SetOnLocalCandidate(OnLocalCandidateCallback cb) {
  on_local_candidate_ = std::move(cb);
}

void WebRTCBridge::SetOnConnectionState(OnConnectionStateCallback cb) {
  on_connection_state_ = std::move(cb);
}

void WebRTCBridge::SetOnIceGatheringDone(OnIceGatheringDoneCallback cb) {
  on_ice_gathering_done_ = std::move(cb);
}

void WebRTCBridge::SubscribeCameraTopic(const std::string &topic) {
  if (current_camera_topic_ == topic && (compressed_image_sub_ || raw_image_sub_)) {
    return;  // 已订阅
  }
  
  UnsubscribeCameraTopic();
  
  current_camera_topic_ = topic;
  
  // 构建 compressed topic 名称
  std::string compressed_topic = topic;
  if (topic.find("/compressed") == std::string::npos) {
    compressed_topic = topic + "/compressed";
  }
  
  // 检查是否有 compressed publisher (来自 compressed_image_transport)
  size_t compressed_pub_count = node_->count_publishers(compressed_topic);
  size_t raw_pub_count = node_->count_publishers(topic);
  
  RCLCPP_INFO(node_->get_logger(),
              "Camera topic scan: compressed '%s' has %zu publishers, raw '%s' has %zu publishers",
              compressed_topic.c_str(), compressed_pub_count,
              topic.c_str(), raw_pub_count);
  
  if (compressed_pub_count > 0) {
    // 优先订阅 compressed topic (JPEG 数据直接转发，省去编码步骤)
    compressed_image_sub_ = node_->create_subscription<sensor_msgs::msg::CompressedImage>(
        compressed_topic, rclcpp::SensorDataQoS(),
        std::bind(&WebRTCBridge::OnCompressedImageReceived, this, std::placeholders::_1));
    
    RCLCPP_INFO(node_->get_logger(),
                "Subscribed to compressed image topic: %s (direct JPEG forwarding)", 
                compressed_topic.c_str());
                
  } else if (raw_pub_count > 0) {
    // 回退到 raw topic，使用 OpenCV 编码为 JPEG
    raw_image_sub_ = node_->create_subscription<sensor_msgs::msg::Image>(
        topic, rclcpp::SensorDataQoS(),
        std::bind(&WebRTCBridge::OnRawImageReceived, this, std::placeholders::_1));
    
    RCLCPP_INFO(node_->get_logger(),
                "Subscribed to raw image topic: %s (will encode to JPEG)", topic.c_str());
                
  } else {
    // 两个都没有 publisher，同时订阅两个 (等待 publisher 出现)
    compressed_image_sub_ = node_->create_subscription<sensor_msgs::msg::CompressedImage>(
        compressed_topic, rclcpp::SensorDataQoS(),
        std::bind(&WebRTCBridge::OnCompressedImageReceived, this, std::placeholders::_1));
    
    raw_image_sub_ = node_->create_subscription<sensor_msgs::msg::Image>(
        topic, rclcpp::SensorDataQoS(),
        std::bind(&WebRTCBridge::OnRawImageReceived, this, std::placeholders::_1));
    
    RCLCPP_WARN(node_->get_logger(),
                "No camera publishers found yet. Subscribed to both '%s' and '%s', waiting for data...",
                compressed_topic.c_str(), topic.c_str());
  }
}

void WebRTCBridge::UnsubscribeCameraTopic() {
  compressed_image_sub_.reset();
  raw_image_sub_.reset();
  current_camera_topic_.clear();
}

size_t WebRTCBridge::GetActivePeerCount() const {
  std::lock_guard<std::mutex> lock(peers_mutex_);
  
  size_t count = 0;
  for (const auto &[id, peer] : peers_) {
    if (peer->IsConnected()) {
      ++count;
    }
  }
  return count;
}

void WebRTCBridge::OnCompressedImageReceived(const sensor_msgs::msg::CompressedImage::SharedPtr msg) {
  if (!msg || msg->data.empty()) {
    return;
  }
  
  uint64_t timestamp_us = static_cast<uint64_t>(msg->header.stamp.sec) * 1000000ULL +
                          static_cast<uint64_t>(msg->header.stamp.nanosec) / 1000ULL;
  
  // 注意：压缩图像（JPEG）无法直接作为 H.264 NAL 发送。
  // 正确的做法是订阅 raw image topic 并用 x264 编码。
  // 这里将 JPEG 数据直接发送仅供调试；
  // 实际部署应切换到 raw image topic + EncodeFrame()。
  RCLCPP_WARN_THROTTLE(node_->get_logger(), *node_->get_clock(), 10000,
      "Sending JPEG frames directly to WebRTC track. "
      "For proper H.264 playback, use raw image topic instead.");
  
  BroadcastFrame(msg->data.data(), msg->data.size(), timestamp_us);
}

void WebRTCBridge::OnRawImageReceived(const sensor_msgs::msg::Image::SharedPtr msg) {
  if (!msg || msg->data.empty()) {
    return;
  }
  
  // 如果同时也有 compressed 订阅收到数据，优先用 compressed（避免重复编码）
  // 这里简单判断：如果 compressed_image_sub_ 存在且有 publisher，跳过 raw
  if (compressed_image_sub_) {
    std::string compressed_topic = current_camera_topic_ + "/compressed";
    if (node_->count_publishers(compressed_topic) > 0) {
      // compressed topic 已有 publisher，取消 raw 订阅以避免重复
      raw_image_sub_.reset();
      RCLCPP_INFO(node_->get_logger(),
                  "Compressed publisher appeared, switching to compressed-only mode");
      return;
    }
  }
  
  uint64_t timestamp_us = static_cast<uint64_t>(msg->header.stamp.sec) * 1000000ULL +
                          static_cast<uint64_t>(msg->header.stamp.nanosec) / 1000ULL;
  
  // 使用 OpenCV 编码 raw Image -> JPEG
  auto encoded = EncodeFrame(msg->data.data(), msg->data.size(), 
                             msg->width, msg->height);
  
  if (!encoded.empty()) {
    BroadcastFrame(encoded.data(), encoded.size(), timestamp_us);
  }
}

void WebRTCBridge::BroadcastFrame(const uint8_t *data, size_t size, uint64_t timestamp_us) {
  std::lock_guard<std::mutex> lock(peers_mutex_);
  
  for (auto &[id, peer] : peers_) {
    if (peer->IsConnected()) {
      peer->SendVideoFrame(data, size, timestamp_us);
    }
  }
}

bool WebRTCBridge::InitEncoder(int width, int height) {
#ifdef X264_ENABLED
  DestroyEncoder();

  x264_param_t param;
  x264_param_default_preset(&param, "ultrafast", "zerolatency");

  param.i_csp = X264_CSP_I420;
  param.i_width = width;
  param.i_height = height;
  param.i_fps_num = 15;
  param.i_fps_den = 1;
  param.i_threads = 2;
  param.i_keyint_max = 30;
  param.i_keyint_min = 15;
  param.b_repeat_headers = 1;
  param.b_annexb = 1;

  param.rc.i_rc_method = X264_RC_ABR;
  param.rc.i_bitrate = 1500;
  param.rc.i_vbv_max_bitrate = 2000;
  param.rc.i_vbv_buffer_size = 2000;

  x264_param_apply_profile(&param, "baseline");

  encoder_ = x264_encoder_open(&param);
  if (!encoder_) {
    RCLCPP_ERROR(node_->get_logger(), "Failed to open x264 encoder");
    return false;
  }

  encoder_width_ = width;
  encoder_height_ = height;
  frame_count_ = 0;

  RCLCPP_INFO(node_->get_logger(),
              "x264 encoder initialized: %dx%d, 15fps, 1500kbps, ultrafast/zerolatency",
              width, height);
  return true;
#else
  (void)width;
  (void)height;
  RCLCPP_WARN_THROTTLE(node_->get_logger(), *node_->get_clock(), 10000,
                       "x264 not available at compile time. "
                       "Install libx264-dev and rebuild with -DX264_ENABLED=ON");
  return false;
#endif
}

void WebRTCBridge::DestroyEncoder() {
#ifdef X264_ENABLED
  if (encoder_) {
    x264_encoder_close(encoder_);
    encoder_ = nullptr;
    RCLCPP_INFO(node_->get_logger(), "x264 encoder destroyed");
  }
#endif
}

std::vector<uint8_t> WebRTCBridge::EncodeFrame(const uint8_t *data, size_t size,
                                                int width, int height) {
  if (!data || size == 0 || width <= 0 || height <= 0) {
    return {};
  }

  // DataChannel 模式：使用 OpenCV 编码为 JPEG（无需 H.264）
  try {
    int channels = static_cast<int>(size) / (width * height);
    int cv_type;

    switch (channels) {
      case 1:
        cv_type = CV_8UC1;
        break;
      case 3:
        cv_type = CV_8UC3;
        break;
      case 4:
        cv_type = CV_8UC4;
        break;
      default:
        RCLCPP_WARN_THROTTLE(node_->get_logger(), *node_->get_clock(), 5000,
                             "Unexpected image format: %dx%d with %zu bytes (%d channels)",
                             width, height, size, channels);
        return {};
    }

    cv::Mat frame(height, width, cv_type, const_cast<uint8_t*>(data));

    cv::Mat bgr_frame;
    if (channels == 3) {
      cv::cvtColor(frame, bgr_frame, cv::COLOR_RGB2BGR);
    } else if (channels == 4) {
      cv::cvtColor(frame, bgr_frame, cv::COLOR_RGBA2BGR);
    } else {
      bgr_frame = frame;
    }

    std::vector<uint8_t> jpeg_buf;
    std::vector<int> params = {cv::IMWRITE_JPEG_QUALITY, 70};

    if (!cv::imencode(".jpg", bgr_frame, jpeg_buf, params)) {
      RCLCPP_WARN_THROTTLE(node_->get_logger(), *node_->get_clock(), 5000,
                           "Failed to encode frame to JPEG");
      return {};
    }

    RCLCPP_DEBUG_THROTTLE(node_->get_logger(), *node_->get_clock(), 5000,
                          "Encoded %dx%d frame to JPEG: %zu bytes",
                          width, height, jpeg_buf.size());

    return jpeg_buf;

  } catch (const cv::Exception &e) {
    RCLCPP_ERROR_THROTTLE(node_->get_logger(), *node_->get_clock(), 5000,
                          "OpenCV exception during JPEG encoding: %s", e.what());
    return {};
  }
}

}  // namespace remote_monitoring

#endif  // WEBRTC_ENABLED
